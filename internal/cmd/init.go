package cmd

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/spf13/cobra"
	"github.com/thirteen37/chezmoi-split/internal/config"
	"github.com/thirteen37/chezmoi-split/internal/path"
)

var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Initialize a split configuration for a target file",
	Long: `Initialize a new split configuration for a target file.

This generates:
- A modify script that calls chezmoi-split merge
- A paths configuration file listing app-owned paths

Example:
  chezmoi split init \
    --template zed-settings.json.tmpl \
    --target .config/zed/settings.json \
    --paths '["agent","default_model"]'`,
	RunE: runInit,
}

var (
	templateName      string
	targetPath        string
	initialPaths      []string
	initStripComments bool
)

func init() {
	initCmd.Flags().StringVarP(&templateName, "template", "t", "", "Template name in .chezmoitemplates (required)")
	initCmd.Flags().StringVar(&targetPath, "target", "", "Target file path relative to home (required)")
	initCmd.Flags().StringArrayVar(&initialPaths, "paths", nil, "App-owned paths as JSON arrays")
	initCmd.Flags().BoolVar(&initStripComments, "strip-comments", false, "Enable JSON comment stripping")

	initCmd.MarkFlagRequired("template")
	initCmd.MarkFlagRequired("target")
}

const modifyScriptTemplate = `#!/bin/bash
# Generated by chezmoi-split - do not edit manually
# Template: {{.TemplateName}}
# Paths config: {{.PathsConfigRelative}}

set -euo pipefail

TEMPLATE_FILE=$(mktemp)
trap 'rm -f "$TEMPLATE_FILE"' EXIT

cat > "$TEMPLATE_FILE" << 'CHEZMOI_SPLIT_TEMPLATE_EOF'
{{"{{"}} template "{{.TemplateName}}" . {{"}}"}}
CHEZMOI_SPLIT_TEMPLATE_EOF

chezmoi-split merge \
  --managed "$TEMPLATE_FILE" \
  --paths '{{"{{"}} .chezmoi.sourceDir {{"}}"}}/{{.PathsConfigRelative}}'{{if .StripComments}} \
  --strip-comments{{end}}
`

func runInit(cmd *cobra.Command, args []string) error {
	// Get chezmoi source directory
	sourceDir, err := getChezmoiSourceDir()
	if err != nil {
		return fmt.Errorf("failed to get chezmoi source dir: %w", err)
	}

	// Parse paths
	var paths [][]string
	for _, p := range initialPaths {
		arrayPath, err := path.ParseArrayPath(p)
		if err != nil {
			return fmt.Errorf("invalid path %q: %w", p, err)
		}
		paths = append(paths, arrayPath.Segments())
	}

	// Determine file locations
	// Target: .config/zed/settings.json -> dot_config/zed/settings.json
	targetDir := filepath.Dir(targetPath)
	targetBase := filepath.Base(targetPath)
	sourceDirPath := convertToChezmoiPath(targetDir)

	// Modify script: modify_private_settings.json.tmpl or modify_settings.json.tmpl
	modifyScriptName := fmt.Sprintf("modify_%s.tmpl", targetBase)
	modifyScriptPath := filepath.Join(sourceDir, sourceDirPath, modifyScriptName)

	// Paths config: .split-settings.json
	pathsConfigName := fmt.Sprintf(".split-%s", targetBase)
	pathsConfigPath := filepath.Join(sourceDir, sourceDirPath, pathsConfigName)
	pathsConfigRelative := filepath.Join(sourceDirPath, pathsConfigName)

	// Create directory if needed
	if err := os.MkdirAll(filepath.Join(sourceDir, sourceDirPath), 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Generate modify script
	tmpl, err := template.New("modify").Parse(modifyScriptTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	f, err := os.Create(modifyScriptPath)
	if err != nil {
		return fmt.Errorf("failed to create modify script: %w", err)
	}
	defer f.Close()

	data := struct {
		TemplateName        string
		PathsConfigRelative string
		StripComments       bool
	}{
		TemplateName:        templateName,
		PathsConfigRelative: pathsConfigRelative,
		StripComments:       initStripComments,
	}

	if err := tmpl.Execute(f, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	// Generate paths config
	cfg := &config.SplitConfig{
		Paths: paths,
		Options: config.Options{
			StripComments: initStripComments,
		},
	}

	if err := cfg.Save(pathsConfigPath); err != nil {
		return fmt.Errorf("failed to save paths config: %w", err)
	}

	fmt.Printf("Created modify script: %s\n", modifyScriptPath)
	fmt.Printf("Created paths config: %s\n", pathsConfigPath)
	return nil
}

// getChezmoiSourceDir returns the chezmoi source directory.
func getChezmoiSourceDir() (string, error) {
	cmd := exec.Command("chezmoi", "source-path")
	output, err := cmd.Output()
	if err != nil {
		// Fallback to default
		home, err := os.UserHomeDir()
		if err != nil {
			return "", err
		}
		return filepath.Join(home, ".local", "share", "chezmoi"), nil
	}
	return strings.TrimSpace(string(output)), nil
}

// convertToChezmoiPath converts a target path to chezmoi source path.
// Example: .config/zed -> dot_config/zed
func convertToChezmoiPath(p string) string {
	parts := strings.Split(p, string(filepath.Separator))
	for i, part := range parts {
		if strings.HasPrefix(part, ".") {
			parts[i] = "dot_" + strings.TrimPrefix(part, ".")
		}
	}
	return filepath.Join(parts...)
}
